{
    "version": "https://jsonfeed.org/version/1",
    "title": "Welcome to my tiny world • All posts by \"最优化\" category",
    "description": "小樊&小小樊的学习笔记🌸",
    "home_page_url": "http://qianqiu-cell.github.io",
    "items": [
        {
            "id": "http://qianqiu-cell.github.io/2022/12/23/optimal/signal_objective_optimization/",
            "url": "http://qianqiu-cell.github.io/2022/12/23/optimal/signal_objective_optimization/",
            "title": "单目标搜索算法汇总",
            "date_published": "2022-12-22T16:00:00.000Z",
            "content_html": "<h1 id=\"一-最近邻搜索nearest-neighbor-search-nns\"><a class=\"markdownIt-Anchor\" href=\"#一-最近邻搜索nearest-neighbor-search-nns\">#</a> 一、最近邻搜索 (Nearest neighbor search, NNS)</h1>\n<p>最近邻搜索算法是为 TSP 编程的最简单的贪婪方法之一。<br>\n<span class=\"label info\">注</span>：贪婪算法是指在对问题求解时，总是做出在<mark>当前看来时最好的选择</mark>，也就是说不从整体最优上加以考虑，算法得到的时在某种意义上的<mark>局部最优解</mark><br>\n NNS 算法的流程为：<br>\n1、首先固定起点城市，并将起点城市当作当前目标城市<br>\n 2、在剩余未被选取的城市中选取距离当前目标城市最近的城市作为下一个目标城市<br>\n 3、重复步骤 2 直到所有城市都被依次选取完毕<br>\n最近邻搜索的过程图如下图所示<br>\n<img data-src=\"/images/signal_objective_optimization/1.1.png\" alt=\"\"></p>\n<h1 id=\"二-试验方法pilot-method\"><a class=\"markdownIt-Anchor\" href=\"#二-试验方法pilot-method\">#</a> 二、试验方法 (Pilot Method)</h1>\n<p><span class=\"label danger\">课本介绍</span>：<br>\n  试验方法列举了通过在初始解中加入一个元素可以得到的所有部分解。然后将引导启发式应用于所有这些部分解，以得到尽可能多的完整解。在最佳完全解的起点的部分解被用作新的起始解，直到没有更多的东西要添加。试验方法的框架需要一个所谓的试点试探法，以完全完成部分解决方案。<br>\n<span class=\"label danger\">自我理解</span>：<br>\n  试验方法的核心思想是基于当前部分解（不完整的解），在每一次迭代的过程中添加不属于当前部分解的元素构成更加完整的下一代部分解集（所有可添加元素添加后的集合），通过其它搜索算法（如最近邻法、2opt 等）将部分解集扩展称为可执行解集，选择目标值最大（或最小）的可执行解对应添加的元素作为插入元素，从而得到下一代更加完整的部分解，重复该过程直到没有元素可以插入（即得到一个完整的解）。<br>\n试验方法流程图如下图所示<br>\n<img data-src=\"/images/signal_objective_optimization/2.1.png\" alt=\"\"></p>\n<h1 id=\"三-最佳改进启发式\"><a class=\"markdownIt-Anchor\" href=\"#三-最佳改进启发式\">#</a> 三、最佳改进启发式</h1>\n<p><span class=\"label danger\">课本介绍</span>：<br>\n  使用最佳改进策略，在每次迭代时彻底检查邻域。所识别的最佳邻居解是用于后续迭代的当前解。<br>\n<span class=\"label danger\">自我理解</span>：<br>\n  最佳改进策略是一种搜索策略，并不代表一种具体的搜索方法。这种策略可以基于其它具体搜索方法（如最近邻、2opt 等），在每次迭代中先找到当前解的所有邻域解，以<mark>最优邻域解</mark>作为下一代的解，直到当前邻域中没有任何一个邻域解优于当前解，则搜索结束。<br>\n改进启发式搜索算法流程图如下图所示<br>\n<img data-src=\"/images/signal_objective_optimization/3.1.png\" alt=\"\"></p>\n<h1 id=\"四-3-opt\"><a class=\"markdownIt-Anchor\" href=\"#四-3-opt\">#</a> 四、3-opt</h1>\n<p>  3-opt 算法是一种针对 TSP 问题的局部搜索算法，通过选取路径中不相邻的三个节点之间的连接删除，然后尝试其它 7 种不同的连接方式，并计算不同连接方式之后的路径长度，选取路径长度最短的连接方式作为新的连接方式，对于路径中不同的三个连接重复此过程，直到所有的三个连接都没有新的连接方式。3-opt 示意图如下图所示<br>\n<img data-src=\"/images/signal_objective_optimization/4.1.png\" alt=\"\"></p>\n<h1 id=\"五-模拟退火算法sa\"><a class=\"markdownIt-Anchor\" href=\"#五-模拟退火算法sa\">#</a> 五、模拟退火算法 (SA)</h1>\n<p>  模拟退火法是最早的局部搜索技术之一，它在每次迭代时并不严格地提高解的质量。模拟退火算法的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。从某一较高初温出发，伴随温度参数的不断下降，结合概率突跳特性在求解空间中随机寻找目标函数的全局最优解，即在陷入局部最优解时能概率性地跳出并最终趋于全局最优。<br>\n  在了解模拟退火算法之前，首先要了解<ins class=\"dot\"> Metropolis 准则</ins>。Metropolis 准则定义了系统由当前状态变为下一状态的接受概率，当下一状态小于当前状态时，接收改状态，否则按照一定概率来接受该状态。Metropolis 准则的公式如下：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>p</mi><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.15999999999999992em\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mfrac><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mi>T</mi></mfrac><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>≥</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">p=\\left\\{\\begin{matrix} \n  1, &amp; E(n+1)&lt;E(n)\\\\  \n  exp(-\\frac{E(n+1)-E(n)}{T} ), &amp; E(n+1)\\ge E(n)\n\\end{matrix}\\right. </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.5700000000000003em;vertical-align:-1.0350000000000004em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.535em;\"><span style=\"top:-3.7049999999999996em;\"><span class=\"pstrut\" style=\"height:3.01em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.3349999999999995em;\"><span class=\"pstrut\" style=\"height:3.01em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0350000000000004em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.535em;\"><span style=\"top:-3.7049999999999996em;\"><span class=\"pstrut\" style=\"height:3.01em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.3349999999999995em;\"><span class=\"pstrut\" style=\"height:3.01em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0350000000000004em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>算法的流程如下<br>\n（1）初始温度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">T=T_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，随机产生一个初始解<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">x_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，并计算其对应的目标函数值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(x_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><br>\n（2）令<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mi>λ</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T=λT</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 或<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mi>T</mi><mrow><mn>1</mn><mo>+</mo><mi>λ</mi><mi>T</mi></mrow></mfrac><mtext> </mtext></mrow><annotation encoding=\"application/x-tex\">T=\\frac{T}{1+\\lambda  T} \\space</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.275662em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">λ</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\"> </span></span></span></span>，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">λ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span> 取值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 之间，为温度下降速度的参数<br>\n（3）对当前解<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2805559999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 施加随机扰动，在其邻域内产生一个新解<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mtext> </mtext></mrow><annotation encoding=\"application/x-tex\">x_{t+1}\\space</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\"> </span></span></span></span>，并计算对应的目标函数值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(x_{t+1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>△</mo><mi>E</mi><mo>=</mo><mi>E</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo><mo>−</mo><mi>E</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bigtriangleup E=E(x_{t+1})-E(x_t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">△</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2805559999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><br>\n（4）按照 Metropoils 准则判断是否接受新解<br>\n（5）重复 L 次扰动和接受过程，即执行步骤 3 和 4，直到温度 T 小于终止温度<br>\n算法流程图如下<br>\n<img data-src=\"/images/signal_objective_optimization/5.2.png\" alt=\"\"></p>\n<h1 id=\"六-噪声方法\"><a class=\"markdownIt-Anchor\" href=\"#六-噪声方法\">#</a> 六、噪声方法</h1>\n<p>  噪声方法的参数是用迭代次数设置的概率分布，在每次评估解时，都会生成随机噪声事件，一般来说，它的期望值为 0，它的方差随着迭代次数的增加而减小，噪声等级分布与迭代次数的关系如下图所示<br>\n<img data-src=\"/images/signal_objective_optimization/6.1.png\" alt=\"\"><br>\n  噪声方法的伪代码如下所示<br>\n<img data-src=\"/images/signal_objective_optimization/6.2.png\" alt=\"\"></p>\n<h1 id=\"七-变邻域搜索vns\"><a class=\"markdownIt-Anchor\" href=\"#七-变邻域搜索vns\">#</a> 七、变邻域搜索 (VNS)</h1>\n<p>  变邻域搜索算法（Variable Neighborhood Search）属于一种局部搜索算法，是指通过改变邻域结构来达到搜索到最优解的过程。<br>\n  VNS 基于以下两个事实：<br>\n  1、一个邻域结构的局部最优解不一定是另一个邻域结构的局部最优解<br>\n  2、全局最优解是所有可能邻域的局部最优解<br>\n  变邻域搜索的伪代码如下所示<br>\n<img data-src=\"/images/signal_objective_optimization/7.1.png\" alt=\"\"></p>\n<h1 id=\"八-贪婪随即自适应搜索算法grasp\"><a class=\"markdownIt-Anchor\" href=\"#八-贪婪随即自适应搜索算法grasp\">#</a> 八、贪婪随即自适应搜索算法 (GRASP)</h1>\n<p>  贪婪随机自适应搜索过程通过局部搜索反复改进用贪婪构造方法获得的解。该方法包括两个参数<ins> Imax</ins>（算法外循环的重复次数）和<ins> α</ins>（用于调整随机化程度）。<br>\n  GRASP 是针对组合优化问题的多起点元启发式方法，其中每个迭代基本上都包含两个阶段，即：<br>\n  (1) 构造阶段 construction<br>\n  (2) 局部搜索阶段 improvement<br>\n  构造阶段构造了一个可接受的解。在局部搜索阶段，GRASP 剖析这个解的邻域，更新解，直到解达到局部最优。更直白的说，GRASP 首先从问题的组成元素中<mark>构造一个解</mark>（在构造阶段），然后<mark>再 “调整” 这个解决方案</mark>（在局部搜索阶段）。</p>\n<h1 id=\"九-lin-kernighan算法lk\"><a class=\"markdownIt-Anchor\" href=\"#九-lin-kernighan算法lk\">#</a> 九、Lin-Kernighan 算法 (LK)</h1>\n<p>  Lin-Kernighan 算法（又称<ins> λ-opt 算法</ins>）属于<mark>局部优化</mark>算法类中的一种，这是因为该算法通过交换边来局部改善现有旅行，被交换的边是通过随机选取的，交换过程持续下去，直到不能再获得更优的解为止。Lin-Kernighan 算法基于 λ- 最优性原理。<br>\n  λ- 最优性原理：如果用任意 λ 条新边取代任意 λ 条现有边获得的新解都不及现有解的成本低，那么现有解满足 λ- 最优（或简记为 λ-opt）。<br>\n  λ 值被预先确定也有不好的一面，这样做将无法通过改变 λ，使算法的运行时间和求解质量获得较好的协调。Lin 和 Kernighan 通过引入了一种称作可变 λ-opt 的启发式算子解决了该问题。他们的算法再执行期间<mark>动态改变 λ 值</mark>。在每一次迭代中，算法都要根据先前运算历史决定是否给目前的 λ 值一个增量，进而通过该 λ 交换获得成本更小的旅行。</p>\n",
            "tags": [
                "最优化"
            ]
        }
    ]
}